# 生活学习工作日记——Day91（2024.10.31）

**日常废话：**今天是十月份的最后一天了，时间真的好快啊，今天周四本应该加班的，但是我感觉实在是太过疲惫了，下了班在公司吃了饭之后就回去了，路上还下起了雨，不喜欢下雨天，到家睡了一会，然后磨磨蹭蹭9点40起来学习，赶紧把算法部分过完吧，后来开始学习ML的内容。

---

**刷题记录：**

```python
# Leetcode 198
# 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，# 如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
# 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

# 思路：寻找数组的子集，要求和最大并且元素不相邻
# 列前6种情形：
# [a]                         --> ans = a
# [a, b]                      --> ans = max(a, b)
# [a, b, c]                   --> ans = max(a+c, b)
# [a, b, c, d]                --> ans = max(a+c, a+d, b+d)
# [a, b, c, d, e]             --> ans = max(a+c+e, a+d, b+d, b+e)
# [a, b, c, d, e, f]          --> ans = max(a+c+e, a+d+f, b+d+f, b+e, a+c+f)
# 每次数组新增一个数，求max的时候包含原最后一个数的元素不会改变，不不包含原最后一个数的元素需要+新增元素
# 每次数组新增一个数，
#    1.如果不使用此数，则结果与上一个数组一样，即ans[i] = ans[i - 1];
#    2.如果使用此数，上一个数不能使用，则结果等于上上个数组+新数，即ans = ans[i - 2] + new_num
# ans[i] = max(ans[i-1], ans[i-2]+new_new)

class Solution:
    def rob(self, nums: List[int]) -> int:
        res = []
        n = len(nums)
        for i in range(n):
            if i == 0:
                res.append(nums[0])
            elif i == 1:
                res.append(max(nums[0], nums[1]))
            else:
                res.append(max(res[i - 1], nums[i] + res[i - 2]))
        return res[-1]
```

dp的题目难点就是找到状态转移方程，想的时候在分析每次新增的是奇数还是偶数，后来多写几个例子然后猛然想到了递推关系，想关系花了差不多40分钟。。。

---

### 2.数据结构/算法

#### 17）Dynamic Programming

```c++
// 求无环图两点间最小路径：遍历所有节点更新i到j之间的路径长度
// Ak[i,j] = min(Ak-1[i,j], A_k-1[i, k]+Ak-1[k, j])
// for k = 1 to |V|
// 	for i = 1 to |V|
//		for j = 1 to |V|
//          A[i][j] = min(A[i][j], A[i][k] + A[k][j])
------------------------------------------------------------
// 计算矩阵链式相乘的最小乘法计算次数
// A1*A2*A3*...*Ak
// n0*n1 n1*n2 n2*n3 ... nk-1*nk --> 维度
// m[i,j] = min(m[i,k]+m[k+1,j]+ni-1*nk*nj  for i = i to j-1)
void main()
{
    int n = 5;  // n-1个矩阵相乘
    int p[] = {5, 4, 6, 2, 7};  // 矩阵的维度A1:5*4, A2:4*6, A3:6*2, A4:2*7
    int m[n][n] = {0};  // 结果
    int s[n][n] = {0};  // 路径
    int j, min, q;
    for(int d = 1; d < n - 1; d++)
    {
        for(int i = 1; i < n - d; i++)
        {
            j = i + d;
            min = 32767;
            for(int k = i; k <= j - 1; k++)
            {
                q = m[i][k]+m[k+1][j]+p[i-1] * p[k] * p[j];
                if(q < min)
                {
                    min = q;
                    s[i][j] = k;
                }
            }
            m[i][j] = min;
        }
    }
}
-----------------------------------------------------------------
//  Bellman ford method
```

视频看完了没看明白，明天再看吧，十二点半了睡觉。