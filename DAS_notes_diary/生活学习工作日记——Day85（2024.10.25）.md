# 生活学习工作日记——Day85（2024.10.25）

**日常废话**：今天终于把一个拖了3天的bug解决了，这个bug非常奇怪是由调用的一个组件引起的，但是部门熟悉这个组件的人已经提桶了，我们连复现bug都复现不了，同事说就按照自己理解的方式修改吧就不验证了，我想想也是复现都复现不了也没办法而且别的事情也很多干别的事情吧。但是leader觉得还是得想办法验证，让我再去研究一下，我也觉得仔细谨慎一点也很对就去搞了，一通研究今天下午终于搞清楚了，原来是在程序一开始静态调用一个函数但这个函数要去获取一个动态的值。解决完之后，我想了一下，我觉得我之前是那种所有事情都需要自己弄清楚才放心的人，做部门兼职的工作需要分析数据，但是这些数据源本身就有问题，我看着就很难受就自己一个个去查，但是事情有很繁杂，后面渐渐地我也无所谓了，工作只要交差就行，跟领导汇报表面工作做好就行，但是吧这样就是又很大风险的，比如这个bug没有验证修复的话后面上线了，出问题我和那位同事就惨了，今天过后我又觉得所有的事情一定要心里有底。同时还反应一个问题，产品质量差导致需要加班做事情，提效提质但是一系列提效操作反而又增加开发的工作量，又降低了质量，这样恶性循环下去，但是这也不是我一个小喽啰能改变的，好好做自己的事，好好做好领导交给我事吧。

---

**刷题记录：**

```python
# Leetcode 287
# 给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。
# 假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。
# 你设计的解决方案必须 不修改 数组 nums 且只用常量级 O(1) 的额外空间。

# 思路:
# 想法就是使用hash或者排序，或者O(n2)遍历，但是都不符合题意
# 看题解：
# 1. 有环链表找起点
# 以0为起点，去数组取值然后把值作为index继续取值，那么含有重复数字的数组就是一个有环链表
# 先使用快慢指针找到快慢指针重回的地方，然后让慢指针再走m步(从头到环入口的距离)就回到了入口
# 走n步后快慢指针重合，慢指针走了n步，快指针走了2n步，快指针比慢指针多走n步(多走了k圈)
# 慢指针在环里面走了n-m步，那么只需要再走m步就回到了环的入口
class Solution:
    def findDuplicate(self, nums):
        pt_slow, pt_fast = 0, 0
        while True:
            pt_slow = nums[pt_slow]
            pt_fast = nums[nums[pt_fast]]
            print(pt_slow)
            print(pt_fast)
            if pt_fast == pt_slow:
                break
        pt0 = 0
        while(pt0 != pt_slow):
            pt0 = nums[pt0]
            pt_slow = nums[pt_slow]
        return pt0
# 2.二分查找，分得不是index是范围
# n+1个数分布在[1, n]范围中，猜重复数是k，如果数组中<=k的次数大于k的话说明重复数一定在[1, k]之间，否则一定在[k+1，n]之间
class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        n = len(nums)
        left, right = 0, n
        while left < right:
            mid = (left + right) // 2
            cnt = sum(num <= mid for num in nums)   # nums中 <=mid 的元素个数
            if cnt <= mid:      # 目标元素在mid右侧
                left = mid+1
            else:
                right = mid
        return left
```

感觉今天很没有状态，明天还要一大早去上班，只能比平时多睡一个小时。。。